{
  "version": 3,
  "sources": ["../src/calculateContentBounds.ts", "../src/characterAnimation.ts", "../src/env-maps/index.ts", "../src/parseXYZ.ts"],
  "sourcesContent": ["import { IVect3, TransformableElement } from \"@mml-io/mml-web\";\n\nexport function calculateContentBounds(rootElement: Element): { min: IVect3; max: IVect3 } {\n  let minX: number | null = null;\n  let minY: number | null = null;\n  let minZ: number | null = null;\n  let maxX: number | null = null;\n  let maxY: number | null = null;\n  let maxZ: number | null = null;\n  const traverse = (element: ChildNode) => {\n    if (TransformableElement.isTransformableElement(element)) {\n      const bounds = element.getContentBounds();\n      if (bounds) {\n        bounds.getCorners().forEach((corner) => {\n          if (minX === null || corner.x < minX) {\n            minX = corner.x;\n          }\n          if (minY === null || corner.y < minY) {\n            minY = corner.y;\n          }\n          if (minZ === null || corner.z < minZ) {\n            minZ = corner.z;\n          }\n          if (maxX === null || corner.x > maxX) {\n            maxX = corner.x;\n          }\n          if (maxY === null || corner.y > maxY) {\n            maxY = corner.y;\n          }\n          if (maxZ === null || corner.z > maxZ) {\n            maxZ = corner.z;\n          }\n        });\n      }\n    }\n    element.childNodes.forEach((child) => {\n      traverse(child);\n    });\n  };\n  traverse(rootElement);\n  if (\n    minX === null ||\n    minY === null ||\n    minZ === null ||\n    maxX === null ||\n    maxY === null ||\n    maxZ === null\n  ) {\n    // Return a default bounding box if no content was found\n    return {\n      min: { x: -0.5, y: -0.5, z: -0.5 },\n      max: { x: 0.5, y: 0.5, z: 0.5 },\n    };\n  }\n\n  return {\n    min: { x: minX, y: minY, z: minZ },\n    max: { x: maxX, y: maxY, z: maxZ },\n  };\n}\n", "// Returns true if a new animation was applied, false if the animation was cleared or unchanged.\nexport function applyCharacterAnimation(mmlRoot: Element, animation: string): boolean {\n  // If the root tag is not an m-character, we don't have a character to animate\n  if (!mmlRoot || mmlRoot.tagName.toString() !== \"M-CHARACTER\") {\n    return false;\n  }\n\n  // Store the original animation attribute so we can restore it later if the animation field is cleared\n  const originalAnimationAttr = \"x-anim\";\n  const originalAnimation = mmlRoot.getAttribute(originalAnimationAttr);\n  const currentAnimation = mmlRoot.getAttribute(\"anim\");\n  if (animation) {\n    // There is an animation to apply\n    if (!originalAnimation) {\n      mmlRoot.setAttribute(originalAnimationAttr, currentAnimation || \"\");\n    }\n    if (currentAnimation !== animation) {\n      mmlRoot.setAttribute(\"anim\", animation);\n      return true;\n    }\n  } else {\n    // There is no animation to apply\n    if (originalAnimation) {\n      // There was an original animation, so we restore it\n      mmlRoot.setAttribute(\"anim\", originalAnimation);\n      mmlRoot.removeAttribute(originalAnimationAttr);\n      return true;\n    }\n  }\n  return false;\n}\n", "type EnvMap = {\n  name: string;\n  url: string;\n};\n\nimport cloudysky from \"./cloudysky_2k.jpg\";\n\nexport const envMaps: {\n  [key: string]: EnvMap;\n} = {\n  cloudysky: {\n    name: \"Cloudy Sky\",\n    url: cloudysky,\n  },\n};\n", "export function parseXYZ(str: string): [number, number, number] {\n  const asNumbers = str\n    .split(\",\")\n    .slice(0, 3)\n    .map(parseFloat)\n    .map((v) => (isNaN(v) ? 0 : v)) as [number, number, number];\n  return [asNumbers[0] || 0, asNumbers[1] || 0, asNumbers[2] || 0];\n}\n"],
  "mappings": "wCAEO,SAASA,EAAuBC,EAAoD,CACzF,IAAIC,EAAsB,KACtBC,EAAsB,KACtBC,EAAsB,KACtBC,EAAsB,KACtBC,EAAsB,KACtBC,EAAsB,KACpBC,EAAYC,GAAuB,CACvC,GAAIC,EAAqB,uBAAuBD,CAAO,EAAG,CACxD,IAAME,EAASF,EAAQ,iBAAiB,EACpCE,GACFA,EAAO,WAAW,EAAE,QAASC,GAAW,EAClCV,IAAS,MAAQU,EAAO,EAAIV,KAC9BA,EAAOU,EAAO,IAEZT,IAAS,MAAQS,EAAO,EAAIT,KAC9BA,EAAOS,EAAO,IAEZR,IAAS,MAAQQ,EAAO,EAAIR,KAC9BA,EAAOQ,EAAO,IAEZP,IAAS,MAAQO,EAAO,EAAIP,KAC9BA,EAAOO,EAAO,IAEZN,IAAS,MAAQM,EAAO,EAAIN,KAC9BA,EAAOM,EAAO,IAEZL,IAAS,MAAQK,EAAO,EAAIL,KAC9BA,EAAOK,EAAO,EAElB,CAAC,CAEL,CACAH,EAAQ,WAAW,QAASI,GAAU,CACpCL,EAASK,CAAK,CAChB,CAAC,CACH,EAEA,OADAL,EAASP,CAAW,EAElBC,IAAS,MACTC,IAAS,MACTC,IAAS,MACTC,IAAS,MACTC,IAAS,MACTC,IAAS,KAGF,CACL,IAAK,CAAE,EAAG,IAAM,EAAG,IAAM,EAAG,GAAK,EACjC,IAAK,CAAE,EAAG,GAAK,EAAG,GAAK,EAAG,EAAI,CAChC,EAGK,CACL,IAAK,CAAE,EAAGL,EAAM,EAAGC,EAAM,EAAGC,CAAK,EACjC,IAAK,CAAE,EAAGC,EAAM,EAAGC,EAAM,EAAGC,CAAK,CACnC,CACF,CC1DO,SAASO,EAAwBC,EAAkBC,EAA4B,CAEpF,GAAI,CAACD,GAAWA,EAAQ,QAAQ,SAAS,IAAM,cAC7C,MAAO,GAIT,IAAME,EAAwB,SACxBC,EAAoBH,EAAQ,aAAaE,CAAqB,EAC9DE,EAAmBJ,EAAQ,aAAa,MAAM,EACpD,GAAIC,GAKF,GAHKE,GACHH,EAAQ,aAAaE,EAAuBE,GAAoB,EAAE,EAEhEA,IAAqBH,EACvB,OAAAD,EAAQ,aAAa,OAAQC,CAAS,EAC/B,WAILE,EAEF,OAAAH,EAAQ,aAAa,OAAQG,CAAiB,EAC9CH,EAAQ,gBAAgBE,CAAqB,EACtC,GAGX,MAAO,EACT,C,oCCvBO,IAAMG,EAET,CACF,UAAW,CACT,KAAM,aACN,IAAKC,CACP,CACF,ECdO,SAASC,EAASC,EAAuC,CAC9D,IAAMC,EAAYD,EACf,MAAM,GAAG,EACT,MAAM,EAAG,CAAC,EACV,IAAI,UAAU,EACd,IAAKE,GAAO,MAAMA,CAAC,EAAI,EAAIA,CAAE,EAChC,MAAO,CAACD,EAAU,CAAC,GAAK,EAAGA,EAAU,CAAC,GAAK,EAAGA,EAAU,CAAC,GAAK,CAAC,CACjE",
  "names": ["calculateContentBounds", "rootElement", "minX", "minY", "minZ", "maxX", "maxY", "maxZ", "traverse", "element", "TransformableElement", "bounds", "corner", "child", "applyCharacterAnimation", "mmlRoot", "animation", "originalAnimationAttr", "originalAnimation", "currentAnimation", "envMaps", "cloudysky_2k_default", "parseXYZ", "str", "asNumbers", "v"]
}
