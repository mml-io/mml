{
  "version": 3,
  "sources": ["../src/calculateContentBounds.ts", "../src/characterAnimation.ts", "../src/env-maps/index.ts", "../src/parseXYZ.ts"],
  "sourcesContent": ["import { IVect3, TransformableElement } from \"@mml-io/mml-web\";\n\nexport function calculateContentBounds(rootElement: Element): { min: IVect3; max: IVect3 } {\n  let minX: number | null = null;\n  let minY: number | null = null;\n  let minZ: number | null = null;\n  let maxX: number | null = null;\n  let maxY: number | null = null;\n  let maxZ: number | null = null;\n  const traverse = (element: ChildNode) => {\n    if (TransformableElement.isTransformableElement(element)) {\n      const bounds = element.getContentBounds();\n      if (bounds) {\n        bounds.getCorners().forEach((corner) => {\n          if (minX === null || corner.x < minX) {\n            minX = corner.x;\n          }\n          if (minY === null || corner.y < minY) {\n            minY = corner.y;\n          }\n          if (minZ === null || corner.z < minZ) {\n            minZ = corner.z;\n          }\n          if (maxX === null || corner.x > maxX) {\n            maxX = corner.x;\n          }\n          if (maxY === null || corner.y > maxY) {\n            maxY = corner.y;\n          }\n          if (maxZ === null || corner.z > maxZ) {\n            maxZ = corner.z;\n          }\n        });\n      }\n    }\n    element.childNodes.forEach((child) => {\n      traverse(child);\n    });\n  };\n  traverse(rootElement);\n  if (\n    minX === null ||\n    minY === null ||\n    minZ === null ||\n    maxX === null ||\n    maxY === null ||\n    maxZ === null\n  ) {\n    // Return a default bounding box if no content was found\n    return {\n      min: { x: -0.5, y: -0.5, z: -0.5 },\n      max: { x: 0.5, y: 0.5, z: 0.5 },\n    };\n  }\n\n  return {\n    min: { x: minX, y: minY, z: minZ },\n    max: { x: maxX, y: maxY, z: maxZ },\n  };\n}\n", "// Returns true if a new animation was applied, false if the animation was cleared or unchanged.\nexport function applyCharacterAnimation(mmlRoot: Element, animation: string): boolean {\n  // If the root tag is not an m-character, we don't have a character to animate\n  if (!mmlRoot || mmlRoot.tagName.toString() !== \"M-CHARACTER\") {\n    return false;\n  }\n\n  // Store the original animation attribute so we can restore it later if the animation field is cleared\n  const originalAnimationAttr = \"x-anim\";\n  const originalAnimation = mmlRoot.getAttribute(originalAnimationAttr);\n  const currentAnimation = mmlRoot.getAttribute(\"anim\");\n  if (animation) {\n    // There is an animation to apply\n    if (!originalAnimation) {\n      mmlRoot.setAttribute(originalAnimationAttr, currentAnimation || \"\");\n    }\n    if (currentAnimation !== animation) {\n      mmlRoot.setAttribute(\"anim\", animation);\n      return true;\n    }\n  } else {\n    // There is no animation to apply\n    if (originalAnimation) {\n      // There was an original animation, so we restore it\n      mmlRoot.setAttribute(\"anim\", originalAnimation);\n      mmlRoot.removeAttribute(originalAnimationAttr);\n      return true;\n    }\n  }\n  return false;\n}\n", "type EnvMap = {\n  name: string;\n  url: string;\n};\n\nimport cloudysky from \"./cloudysky_2k.jpg\";\n\nexport const envMaps: {\n  [key: string]: EnvMap;\n} = {\n  cloudysky: {\n    name: \"Cloudy Sky\",\n    url: cloudysky,\n  },\n};\n", "export function parseXYZ(str: string): [number, number, number] {\n  const asNumbers = str\n    .split(\",\")\n    .slice(0, 3)\n    .map(parseFloat)\n    .map((v) => (isNaN(v) ? 0 : v)) as [number, number, number];\n  return [asNumbers[0] || 0, asNumbers[1] || 0, asNumbers[2] || 0];\n}\n"],
  "mappings": ";;;;;AAEO,SAAS,uBAAuB,aAAoD;AACzF,MAAI,OAAsB;AAC1B,MAAI,OAAsB;AAC1B,MAAI,OAAsB;AAC1B,MAAI,OAAsB;AAC1B,MAAI,OAAsB;AAC1B,MAAI,OAAsB;AAC1B,QAAM,WAAW,CAAC,YAAuB;AACvC,QAAI,qBAAqB,uBAAuB,OAAO,GAAG;AACxD,YAAM,SAAS,QAAQ,iBAAiB;AACxC,UAAI,QAAQ;AACV,eAAO,WAAW,EAAE,QAAQ,CAAC,WAAW;AACtC,cAAI,SAAS,QAAQ,OAAO,IAAI,MAAM;AACpC,mBAAO,OAAO;AAAA,UAChB;AACA,cAAI,SAAS,QAAQ,OAAO,IAAI,MAAM;AACpC,mBAAO,OAAO;AAAA,UAChB;AACA,cAAI,SAAS,QAAQ,OAAO,IAAI,MAAM;AACpC,mBAAO,OAAO;AAAA,UAChB;AACA,cAAI,SAAS,QAAQ,OAAO,IAAI,MAAM;AACpC,mBAAO,OAAO;AAAA,UAChB;AACA,cAAI,SAAS,QAAQ,OAAO,IAAI,MAAM;AACpC,mBAAO,OAAO;AAAA,UAChB;AACA,cAAI,SAAS,QAAQ,OAAO,IAAI,MAAM;AACpC,mBAAO,OAAO;AAAA,UAChB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,YAAQ,WAAW,QAAQ,CAAC,UAAU;AACpC,eAAS,KAAK;AAAA,IAChB,CAAC;AAAA,EACH;AACA,WAAS,WAAW;AACpB,MACE,SAAS,QACT,SAAS,QACT,SAAS,QACT,SAAS,QACT,SAAS,QACT,SAAS,MACT;AAEA,WAAO;AAAA,MACL,KAAK,EAAE,GAAG,MAAM,GAAG,MAAM,GAAG,KAAK;AAAA,MACjC,KAAK,EAAE,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI;AAAA,IAChC;AAAA,EACF;AAEA,SAAO;AAAA,IACL,KAAK,EAAE,GAAG,MAAM,GAAG,MAAM,GAAG,KAAK;AAAA,IACjC,KAAK,EAAE,GAAG,MAAM,GAAG,MAAM,GAAG,KAAK;AAAA,EACnC;AACF;;;AC1DO,SAAS,wBAAwB,SAAkB,WAA4B;AAEpF,MAAI,CAAC,WAAW,QAAQ,QAAQ,SAAS,MAAM,eAAe;AAC5D,WAAO;AAAA,EACT;AAGA,QAAM,wBAAwB;AAC9B,QAAM,oBAAoB,QAAQ,aAAa,qBAAqB;AACpE,QAAM,mBAAmB,QAAQ,aAAa,MAAM;AACpD,MAAI,WAAW;AAEb,QAAI,CAAC,mBAAmB;AACtB,cAAQ,aAAa,uBAAuB,oBAAoB,EAAE;AAAA,IACpE;AACA,QAAI,qBAAqB,WAAW;AAClC,cAAQ,aAAa,QAAQ,SAAS;AACtC,aAAO;AAAA,IACT;AAAA,EACF,OAAO;AAEL,QAAI,mBAAmB;AAErB,cAAQ,aAAa,QAAQ,iBAAiB;AAC9C,cAAQ,gBAAgB,qBAAqB;AAC7C,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;A;;;;;ACvBO,IAAM,UAET;AAAA,EACF,WAAW;AAAA,IACT,MAAM;AAAA,IACN,KAAK;AAAA,EACP;AACF;;;ACdO,SAAS,SAAS,KAAuC;AAC9D,QAAM,YAAY,IACf,MAAM,GAAG,EACT,MAAM,GAAG,CAAC,EACV,IAAI,UAAU,EACd,IAAI,CAAC,MAAO,MAAM,CAAC,IAAI,IAAI,CAAE;AAChC,SAAO,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;AACjE;",
  "names": []
}
